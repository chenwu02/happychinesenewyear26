<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2026æ–°å¹´å¿«ä¹</title>

<script src="https://cdn.tailwindcss.com"></script>

<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

<style>
body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}

/* ===== å¼€å§‹é¡µé¢ ===== */
#startScreen {
    position: fixed;
    inset: 0;
    background: black;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    flex-direction: column;
}

#startButton {
    padding: 20px 50px;
    font-size: 28px;
    background: white;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: 0.3s;
}

#startButton:hover {
    background: #ddd;
}

#root {
    width: 100%;
    height: 100%;
    display: none; /* é»˜è®¤éšè— */
}
</style>

<script type="importmap">
{
    "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "three": "https://esm.sh/three@0.160.0",
        "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
        "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber"
    }
}
</script>

<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>

<!-- ===== å¼€å§‹é¡µé¢ ===== -->
<div id="startScreen">
    <button id="startButton">ğŸ§¨ç‚¹å‡»è¿›å…¥ 2026</button>
</div>

<!-- ===== èƒŒæ™¯éŸ³ä¹ ===== -->
<audio id="bgm" loop>
    <source src="music.mp3" type="audio/mp3">
</audio>

<!-- ===== React Root ===== -->
<div id="root"></div>

<script>
const startButton = document.getElementById("startButton");
const startScreen = document.getElementById("startScreen");
const rootDiv = document.getElementById("root");
const bgm = document.getElementById("bgm");

startButton.addEventListener("click", () => {

    // æ˜¾ç¤ºä¸»ç¨‹åº
    rootDiv.style.display = "block";
    startScreen.style.display = "none";

    // è‡ªåŠ¨æ’­æ”¾éŸ³ä¹
    bgm.play().catch(e => console.log("æ’­æ”¾è¢«é˜»æ­¢:", e));
});
</script>

<!-- =========================
     ä¸‹é¢ä¿æŒä½ åŸæ¥çš„å®Œæ•´ React ä»£ç 
     æœªæ”¹åŠ¨ä»»ä½•åŠŸèƒ½
========================= -->

<script type="text/babel" data-type="module">
	import React, { useMemo, useRef, useState, useEffect, useCallback, useLayoutEffect } from 'react';
        import ReactDOM from 'react-dom/client';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { Points, PointMaterial, Float } from '@react-three/drei';
        import * as THREE from 'three';

        // --- Configuration ---
        const SCENE_PARTICLE_COUNT = 18000;
        const SHAPE_SWITCH_INTERVAL = 8000;
        const PARTICLE_SIZE = 0.035;
        const TRANSITION_SPEED = 0.025;

        // --- Palette ---
        const PALETTE = {
            GOLD: new THREE.Color('#FFD700').multiplyScalar(1.5),
            RED: new THREE.Color('#FF4500').multiplyScalar(1.2),
            GREEN: new THREE.Color('#00FF7F'),
            DARK_GREEN: new THREE.Color('#006400'),
            WHITE: new THREE.Color('#FFFFFF').multiplyScalar(1.2),
            BLUE: new THREE.Color('#00BFFF'),
            ORANGE: new THREE.Color('#FFA500'),
            WOOD: new THREE.Color('#3E2723'),
            TEXT_MAIN: new THREE.Color('#F0F8FF'),
            TEXT_ACCENT: new THREE.Color('#00FFFF'),
            PURPLE: new THREE.Color('#D6A2E8'),
            RIBBON: new THREE.Color('#FF1493'),
        };

        // --- Utils ---
        const randomRange = (min, max) => Math.random() * (max - min) + min;

        // --- Advanced Shape Generators (Scene Objects) ---
        // (We will use this logic in the visualizer too!)
        
        const generateTree = (i) => {
            const p = i / SCENE_PARTICLE_COUNT;
            if (p < 0.01) return { pos: [randomRange(-0.2, 0.2), 3.2 + randomRange(-0.2, 0.2), randomRange(-0.2, 0.2)], color: PALETTE.GOLD };
            // ... (Full implementation hidden for brevity in rendering, but logically present)
             const tierConfigs = [
                [1.5, 3.0, 1.2, 0.0],
                [0.0, 1.8, 1.8, 0.5],
                [-1.5, 0.3, 2.4, 0.8],
                [-2.5, -1.5, 0.6, 0.6]
            ];
            const r = Math.random();
            let tier = 0;
            if (r < 0.1) tier = 3;
            else if (r < 0.4) tier = 0;
            else if (r < 0.7) tier = 1;
            else tier = 2;
            const config = tierConfigs[tier];
            if (tier === 3) {
                const h = randomRange(config[0], config[1]);
                const theta = Math.random() * Math.PI * 2;
                const rad = Math.random() * config[2];
                return { pos: [Math.cos(theta) * rad, h, Math.sin(theta) * rad], color: PALETTE.WOOD };
            }
            const [minY, maxY, maxR, minR] = config;
            const hNorm = Math.random();
            const y = minY + hNorm * (maxY - minY);
            const rAtHeight = maxR - hNorm * (maxR - minR);
            const radius = Math.random() > 0.4 ? rAtHeight : rAtHeight * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const droop = radius * 0.4;
            const pos = [Math.cos(theta) * radius, y - droop * (radius / maxR), Math.sin(theta) * radius];
            const spiralVal = (y * 5 + theta) % (Math.PI * 2);
            if (Math.abs(spiralVal) < 0.2 && radius > rAtHeight * 0.8) return { pos, color: PALETTE.GOLD };
            if (Math.random() < 0.08 && radius > 0.5) return { pos, color: Math.random() > 0.5 ? PALETTE.RED : PALETTE.BLUE };
            return { pos, color: Math.random() > 0.6 ? PALETTE.GREEN : PALETTE.DARK_GREEN };
        };

        const generateSnowman = (i) => {
            const r = Math.random();
            if (r < 0.04) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const len = Math.random() * 1.5 + 0.5;
                const angle = 0.3;
                const x = (0.7 + len * Math.cos(angle)) * side;
                const y = 0.5 + len * Math.sin(angle);
                const z = (Math.random() - 0.5) * 0.2;
                return { pos: [x, y, z], color: PALETTE.WOOD };
            }
            if (r < 0.09) {
                const theta = Math.random() * Math.PI * 2;
                const ringR = 0.85;
                if (Math.random() < 0.15) return { pos: [0.5, 0.8 - Math.random() * 1.2, 0.85 + (Math.random() - 0.5) * 0.2], color: PALETTE.RED };
                return { pos: [Math.cos(theta) * ringR, 1.1 + (Math.random() - 0.5) * 0.15, Math.sin(theta) * ringR], color: PALETTE.RED };
            }
            if (r < 0.45) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const rad = 1.6;
                return { pos: [rad * Math.sin(phi) * Math.cos(theta), -2.0 + rad * Math.sin(phi) * Math.sin(theta), rad * Math.cos(phi)], color: PALETTE.WHITE };
            }
            if (r < 0.75) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const rad = 1.1;
                const p = [rad * Math.sin(phi) * Math.cos(theta), 0.2 + rad * Math.sin(phi) * Math.sin(theta), rad * Math.cos(phi)];
                if (p[2] > 0.9 && Math.abs(p[0]) < 0.2) return { pos: p, color: PALETTE.DARK_GREEN };
                return { pos: p, color: PALETTE.WHITE };
            }
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const rad = 0.85;
            const p = [rad * Math.sin(phi) * Math.cos(theta), 2.1 + rad * Math.sin(phi) * Math.sin(theta), rad * Math.cos(phi)];
            if (p[2] > 0.7 && p[1] > 2.0 && p[1] < 2.2 && Math.abs(p[0]) < 0.15) return { pos: [p[0], p[1], p[2] + Math.random() * 0.5], color: PALETTE.ORANGE };
            if (p[2] > 0.6 && p[1] > 2.25 && Math.abs(p[0]) > 0.2 && Math.abs(p[0]) < 0.4) return { pos: p, color: PALETTE.DARK_GREEN };
            if (p[1] > 2.7) return { pos: [p[0], p[1] + 0.2, p[2]], color: new THREE.Color('#222') };
            return { pos: p, color: PALETTE.WHITE };
        };

        const generateWreath = (i) => {
            const majorRadius = 2.2;
            const minorRadius = 0.75;
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI * 2;
            const r = minorRadius * (0.8 + 0.4 * Math.random());
            const x = (majorRadius + r * Math.cos(v)) * Math.cos(u);
            const y = (majorRadius + r * Math.cos(v)) * Math.sin(u);
            const z = r * Math.sin(v);

            if (u > 4.5 && u < 4.9) return { pos: [x, y, z + 0.5], color: PALETTE.RED };
            if (Math.random() < 0.05) return { pos: [x * 1.08, y * 1.08, z * 1.08], color: PALETTE.RED };
            if (Math.random() < 0.03) return { pos: [x * 1.1, y * 1.1, z * 1.1], color: PALETTE.GOLD };

            return { pos: [x, y, z], color: Math.random() > 0.5 ? PALETTE.GREEN : PALETTE.DARK_GREEN };
        };

        const generateGift = (i) => {
            const size = 3.5;
            const half = size / 2;
            let x = (Math.random() - 0.5) * size;
            let y = (Math.random() - 0.5) * size;
            let z = (Math.random() - 0.5) * size;

            const axis = Math.floor(Math.random() * 3);
            if (axis === 0) x = x > 0 ? half : -half;
            else if (axis === 1) y = y > 0 ? half : -half;
            else z = z > 0 ? half : -half;

            const ribbonWidth = 0.6;
            if ((Math.abs(x) < ribbonWidth && Math.abs(z) > ribbonWidth) || (Math.abs(z) < ribbonWidth && Math.abs(x) > ribbonWidth)) {
                return { pos: [x * 1.02, y * 1.02, z * 1.02], color: PALETTE.RIBBON };
            }

            if (y > half - 0.1 && Math.random() < 0.15) {
                const t = Math.random() * Math.PI * 2;
                const bowR = Math.random() * 1.0;
                const by = half + 0.5 + Math.sin(t * 3) * 0.3;
                return { pos: [Math.cos(t) * bowR, by, Math.sin(t) * bowR], color: PALETTE.RIBBON };
            }

            return { pos: [x, y, z], color: PALETTE.PURPLE };
        };

        const generateSleigh = (i) => {
            const r = Math.random();
            if (r < 0.15) {
                const t = (i / (SCENE_PARTICLE_COUNT * 0.15)) * Math.PI * 2;
                const x = (t / (Math.PI * 2)) * 6 - 3;
                const y = Math.sin(t) * 0.5 - 2.5;
                const side = Math.random() > 0.5 ? 1.4 : -1.4;
                const z = side + (Math.random() - 0.5) * 0.2;
                return { pos: [x, y + (Math.random() - 0.5) * 0.1, z], color: PALETTE.GOLD };
            }
            if (r < 0.35) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const rad = 1.2;
                const x = -1.5 + rad * Math.sin(phi) * Math.cos(theta);
                const y = -0.5 + rad * Math.sin(phi) * Math.sin(theta);
                const z = rad * Math.cos(phi) * 0.8;
                if (y > -1.0)
                    return { pos: [x, y, z], color: Math.random() > 0.5 ? PALETTE.RIBBON : PALETTE.BLUE };
            }
            const t = Math.random();
            const u = Math.random();
            const x = t * 5 - 2.5;
            const width = 2.4 * Math.sin(t * Math.PI);
            const z = (u > 0.5 ? 1 : -1) * width * 0.5;
            const yBase = -1.5 + (x > 1 ? (x - 1) * (x - 1) * 0.4 : 0) + (x < -1.5 ? (x + 1.5) * (x + 1.5) * 0.6 : 0);
            if (Math.random() < 0.3) return { pos: [x, yBase, (Math.random() - 0.5) * width], color: PALETTE.RED };
            return { pos: [x, yBase + (Math.random()) * 1.2, z], color: PALETTE.RED };
        };

        const generate2026 = (i) => {
            // Divide particles into 4 groups for 2, 0, 2, 6
            const d = Math.floor((i / SCENE_PARTICLE_COUNT) * 4); 
            const xOffsets = [-2.5, -0.8, 0.8, 2.5];
            const xOff = xOffsets[d];
            
            const r = Math.random();
            let pos = [0, 0, 0];
            let color = PALETTE.GOLD;

            const get2 = () => {
                if (r < 0.35) {
                    // Top Arc
                    const angle = Math.PI * (1 - (r / 0.35)); 
                    const rad = 0.5 + (Math.random()-0.5)*0.1;
                    return [rad * Math.cos(angle), 0.5 + rad * Math.sin(angle), 0];
                } else if (r < 0.7) {
                    // Diagonal
                    const t = (r - 0.35) / 0.35;
                    const x = 0.5 - t * 1.0;
                    const y = 0.5 - t * 1.0;
                    return [x + (Math.random()-0.5)*0.1, y + (Math.random()-0.5)*0.1, 0];
                } else {
                    // Bottom Line
                    const t = (r - 0.7) / 0.3;
                    const x = -0.5 + t * 1.0;
                    return [x, -0.5 + (Math.random()-0.5)*0.1, 0];
                }
            };

            const get0 = () => {
                const angle = Math.random() * Math.PI * 2;
                const radX = 0.5 + (Math.random()-0.5)*0.1;
                const radY = 0.7 + (Math.random()-0.5)*0.1;
                return [radX * Math.cos(angle), radY * Math.sin(angle), 0];
            };

            const get6 = () => {
                if (r < 0.5) {
                    // Bottom Loop
                    const angle = Math.random() * Math.PI * 2;
                    const rad = 0.4 + (Math.random()-0.5)*0.1;
                    return [rad * Math.cos(angle), -0.3 + rad * Math.sin(angle), 0];
                } else {
                    // Top Stem
                    const t = (r - 0.5) / 0.5;
                    const p0 = [-0.4, -0.3];
                    const p1 = [-0.6, 0.4];
                    const p2 = [0.3, 0.8];
                    const mt = 1-t;
                    const x = mt*mt*p0[0] + 2*mt*t*p1[0] + t*t*p2[0];
                    const y = mt*mt*p0[1] + 2*mt*t*p1[1] + t*t*p2[1];
                    return [x + (Math.random()-0.5)*0.1, y + (Math.random()-0.5)*0.1, 0];
                }
            };

            if (d === 0 || d === 2) {
                pos = get2();
                // Alternating colors for 2
                color = Math.random() > 0.5 ? PALETTE.GOLD : PALETTE.RED;
            } else if (d === 1) {
                pos = get0();
                // Alternating colors for 0
                color = Math.random() > 0.5 ? PALETTE.RED : PALETTE.GOLD;
            } else {
                pos = get6();
                // Alternating colors for 6
                color = Math.random() > 0.5 ? PALETTE.GOLD : PALETTE.RED;
            }
            
            pos[0] += xOff;
            // Scale and Position
            pos[0] *= 1.1;
            pos[1] *= 1.1;
            pos[2] = (Math.random() - 0.5) * 0.5;
            
            // Add sparkle effect to colors (random variation)
            if (Math.random() < 0.2) {
                 color = PALETTE.WHITE;
            }
            
            return { pos, color };
        };

        const generateFireworkVariation = (i, variant) => {
             // Increase explosion count for more density
             const explosionCount = 8;
             const groupSize = Math.floor(SCENE_PARTICLE_COUNT / explosionCount);
             const groupIndex = Math.floor(i / groupSize);
             const particleInGroup = i % groupSize;
             const progress = particleInGroup / groupSize; // 0 to 1
             
             // Seed for position
             const seed = groupIndex * 13.0 + variant * 7.0;
             const centerX = Math.sin(seed) * 5;
             const centerY = Math.cos(seed * 1.5) * 2 + 0.5; 
             const centerZ = Math.sin(seed * 2.3) * 3;
             
             let x, y, z;
             
             // Improved distributions
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos(2 * Math.random() - 1);
             
             // Base random for variety
             const rBase = Math.random();

             if (variant === 0) {
                 // Realistic Sphere Burst with Trails
                 // Particles should be denser at the edge (expanding shell) but with trails filling the inside
                 
                 // Distance from center: biased towards 1.0 (shell) but with trail falloff
                 // Use a power curve to simulate explosion force distribution
                 const velocity = 3.5 * (0.2 + 0.8 * Math.pow(rBase, 0.5)); 
                 
                 // Simulating a snapshot in time: Pos = Center + Velocity * Direction
                 // Add drag/air resistance simulation: outer particles slow down less than inner ones? 
                 // Actually, usually we simulate "trails" by just filling the sphere volume non-uniformly.
                 
                 const rad = velocity; 
                 
                 x = centerX + rad * Math.sin(phi) * Math.cos(theta);
                 y = centerY + rad * Math.sin(phi) * Math.sin(theta);
                 z = centerZ + rad * Math.cos(phi);
                 
                 // Gravity droop increases with distance (time)
                 // Outer particles (older/further) droop more
                 y -= Math.pow(rad/3.5, 2) * 1.2;
                 
             } else if (variant === 1) {
                 // Double Ring / Saturn with Sparks
                 const isRing = rBase > 0.3;
                 
                 if (isRing) {
                     // Main Ring
                     const angle = theta;
                     const rad = 2.8 + (Math.random()-0.5) * 0.1;
                     x = centerX + rad * Math.cos(angle);
                     y = centerY + (Math.random()-0.5) * 0.1;
                     z = centerZ + rad * Math.sin(angle);
                     
                     // Tilt
                     const tiltX = 0.4;
                     const tiltZ = 0.2;
                     
                     let yOld = y;
                     y = y * Math.cos(tiltX) - z * Math.sin(tiltX);
                     z = yOld * Math.sin(tiltX) + z * Math.cos(tiltX);

                 } else {
                     // Inner chaotic core / second smaller ring
                     const rad = Math.random() * 1.2;
                     // Random scatter
                     x = centerX + rad * Math.sin(phi) * Math.cos(theta);
                     y = centerY + rad * Math.sin(phi) * Math.sin(theta);
                     z = centerZ + rad * Math.cos(phi);
                 }
                 
             } else {
                 // Palm / Willow Effect
                 // Distinct arms that trail downwards heavily
                 const arms = 12; // Fewer, distinct arms
                 const armIndex = Math.floor(rBase * arms);
                 
                 // Variation within arm
                 const t = Math.random(); // Position along the arm
                 
                 // Base direction for this arm
                 // Distribute arms on a sphere roughly
                 const armPhi = Math.acos(1 - 2 * (armIndex + 0.5) / arms);
                 const armTheta = Math.PI * (1 + Math.sqrt(5)) * (armIndex + 0.5);
                 
                 // Add some spread to the arm
                 const spread = 0.1 * t;
                 const finalPhi = armPhi + (Math.random()-0.5) * spread;
                 const finalTheta = armTheta + (Math.random()-0.5) * spread;
                 
                 const dist = t * 4.5; // Long trails
                 
                 x = centerX + dist * Math.sin(finalPhi) * Math.cos(finalTheta);
                 y = centerY + dist * Math.sin(finalPhi) * Math.sin(finalTheta);
                 z = centerZ + dist * Math.cos(finalPhi);
                 
                 // Heavy gravity for willow effect
                 // The further out (longer time), the more it drops
                 y -= Math.pow(dist, 1.8) * 0.15; 
             }
             
             // Colors with better gradients and brightness
             const baseColors = [PALETTE.RED, PALETTE.GOLD, PALETTE.PURPLE, PALETTE.BLUE, PALETTE.GREEN, PALETTE.RIBBON];
             let color = baseColors[(groupIndex + variant) % baseColors.length].clone();
             
             // Realistic intensity variation
             // Center is brighter (hotter), edges are cooler or fading
             // Or randomized "twinkle"
             
             if (Math.random() < 0.15) {
                 // Sparkling particles
                 color = new THREE.Color('#FFFFFF').multiplyScalar(2.0);
             } else {
                 // Add some color variation
                 color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
                 
                 // Brighter core
                 const distFromCenter = Math.sqrt((x-centerX)**2 + (y-centerY)**2 + (z-centerZ)**2);
                 if (distFromCenter < 1.0) {
                     color.multiplyScalar(1.5);
                 }
             }
             
             return { pos: [x, y, z], color: color };
        };

        const generateChineseKnot = (i) => {
            const r = Math.random();
            const KNOT_RED = new THREE.Color('#FF0000'); // Pure Red requested by user
            
            // 1. Main Body: Diamond Shape (Rotated Square)
            // Center at y=0.5
            if (r < 0.55) {
                // Generate points in a square
                const u = (Math.random() - 0.5) * 2.2; // Width
                const v = (Math.random() - 0.5) * 2.2; // Height
                
                // Rotate 45 degrees to make a diamond
                const angle = Math.PI / 4;
                const x = u * Math.cos(angle) - v * Math.sin(angle);
                const y = u * Math.sin(angle) + v * Math.cos(angle) + 0.5;
                
                // Simple texture: mostly solid but with some grid hints
                const isEdge = Math.abs(u) > 0.9 || Math.abs(v) > 0.9;
                const z = (Math.random() - 0.5) * (isEdge ? 0.4 : 0.2);
                
                return { pos: [x, y, z], color: KNOT_RED };
            }
            
            // 2. Tassels (The most iconic part)
            if (r < 0.85) {
                const tasselId = Math.floor(Math.random() * 2); // 0 or 1
                const xOffset = (tasselId === 0 ? -0.4 : 0.4);
                
                const t = Math.random(); // 0 to 1 down the tassel
                const length = 3.0;
                const yTop = -0.8;
                const y = yTop - t * length;
                
                // Sway logic
                const swayFreq = 3.0;
                const swayAmp = 0.1 * t; // More sway at bottom
                const x = xOffset + Math.sin(y * swayFreq) * swayAmp + (Math.random()-0.5)*0.1;
                const z = (Math.random()-0.5)*0.1;
                
                return { pos: [x, y, z], color: KNOT_RED };
            }
            
            // 3. Gold Embellishments (Center and connections)
            if (r < 0.95) {
                // Center Emblem
                const theta = Math.random() * Math.PI * 2;
                const rad = Math.random() * 0.5;
                return { pos: [Math.cos(theta) * rad, 0.5, Math.sin(theta) * rad], color: PALETTE.GOLD };
            }
            
            // 4. Top Hanging Cord
            {
                const y = 1.8 + Math.random() * 1.5;
                return { pos: [(Math.random()-0.5)*0.05, y, 0], color: KNOT_RED };
            }
        };

        const generateFW1 = (i) => generateFireworkVariation(i, 0);
        const generateFW2 = (i) => generateFireworkVariation(i, 1);
        const generateFW3 = (i) => generateFireworkVariation(i, 2);
        const generateFW4 = (i) => generateFireworkVariation(i, 0); // Repeat sphere with different seed/pos implicitly

        const SCENE_SHAPES = [generateChineseKnot, generateFW1, generateFW2, generateFW3, generateFW4];

        const FallingSnow = () => {
            const count = 1000;
            const points = useRef(null);
            const [positions, speeds] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const spd = new Float32Array(count);
                for (let i = 0; i < count; i++) {
                    pos[i * 3] = (Math.random() - 0.5) * 20;
                    pos[i * 3 + 1] = (Math.random() - 0.5) * 20 + 5;
                    pos[i * 3 + 2] = (Math.random() - 0.5) * 10 - 2;
                    spd[i] = Math.random() * 0.05 + 0.02;
                }
                return [pos, spd];
            }, []);

            useFrame(() => {
                if (!points.current) return;
                const posAttr = points.current.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    let y = posAttr.array[i * 3 + 1];
                    y -= speeds[i];
                    if (y < -6) y = 8;
                    posAttr.array[i * 3 + 1] = y;
                    posAttr.array[i * 3] += Math.sin(y) * 0.002;
                }
                posAttr.needsUpdate = true;
            });

            return (
                <Points ref={points} positions={positions} stride={3} frustumCulled={false}>
                    <PointMaterial transparent color="#ffffff" size={0.06} opacity={0.6} depthWrite={false} />
                </Points>
            );
        };

        const MorphingScene = ({ shapeIndex }) => {
            const pointsRef = useRef(null);

            const shapes = useMemo(() => {
                return SCENE_SHAPES.map(gen => {
                    const pos = new Float32Array(SCENE_PARTICLE_COUNT * 3);
                    const col = new Float32Array(SCENE_PARTICLE_COUNT * 3);
                    for (let i = 0; i < SCENE_PARTICLE_COUNT; i++) {
                        const d = gen(i);
                        pos[i * 3] = d.pos[0]; pos[i * 3 + 1] = d.pos[1]; pos[i * 3 + 2] = d.pos[2];
                        col[i * 3] = d.color.r; col[i * 3 + 1] = d.color.g; col[i * 3 + 2] = d.color.b;
                    }
                    return { pos, col };
                });
            }, []);

            const [currentPositions] = useState(() => new Float32Array(SCENE_PARTICLE_COUNT * 3));
            const [currentColors] = useState(() => new Float32Array(SCENE_PARTICLE_COUNT * 3));

            useMemo(() => {
                currentPositions.set(shapes[0].pos);
                currentColors.set(shapes[0].col);
            }, []);

            useFrame((state) => {
                if (!pointsRef.current) return;
                const time = state.clock.getElapsedTime();
                const target = shapes[shapeIndex];

                const posAttr = pointsRef.current.geometry.attributes.position;
                const colAttr = pointsRef.current.geometry.attributes.color;

                for (let i = 0; i < SCENE_PARTICLE_COUNT; i++) {
                    const ix = i * 3;
                    const noise = Math.sin(time * 3 + i * 0.1) * 0.003;

                    currentPositions[ix] += (target.pos[ix] - currentPositions[ix]) * TRANSITION_SPEED + noise;
                    currentPositions[ix + 1] += (target.pos[ix + 1] - currentPositions[ix + 1]) * TRANSITION_SPEED + noise;
                    currentPositions[ix + 2] += (target.pos[ix + 2] - currentPositions[ix + 2]) * TRANSITION_SPEED + noise;

                    currentColors[ix] += (target.col[ix] - currentColors[ix]) * 0.05;
                    currentColors[ix + 1] += (target.col[ix + 1] - currentColors[ix + 1]) * 0.05;
                    currentColors[ix + 2] += (target.col[ix + 2] - currentColors[ix + 2]) * 0.05;
                }

                posAttr.needsUpdate = true;
                colAttr.needsUpdate = true;
                pointsRef.current.rotation.y = time * 0.15;
            });

            return (
                <group position={[0, 0, 0]}>
                    <Points ref={pointsRef} positions={currentPositions} colors={currentColors} stride={3}>
                        <PointMaterial transparent vertexColors size={PARTICLE_SIZE} sizeAttenuation={true} depthWrite={false} blending={THREE.AdditiveBlending} opacity={1.0} />
                    </Points>
                </group>
            );
        };

        const Resizer = () => {
            const { viewport, camera } = useThree();
            
            useFrame(() => {
                if (camera.isPerspectiveCamera) {
                    camera.aspect = viewport.width / viewport.height;
                    camera.updateProjectionMatrix();
                }
            });
            
            return null;
        };

        // --- Auto Typing Background Component ---
        
        // This is the code we will "type" out. It mimics the actual file structure.
        const SOURCE_CODE_TEXT = `

é©¬å¹´æ–°æ˜¥ï¼Œä¸‡è±¡å¥”è…¾ã€‚

æ„¿ä½ åœ¨æ–°çš„ä¸€å¹´é‡Œï¼Œå¦‚éªé©¬æ‰¬è¹„ï¼Œæ­¥å±¥åšå®šã€ç›®å…‰æ¸…æœ—â€”â€”
æ„¿å­¦ä¸šå¦‚éªé©¬è¸æ˜¥ï¼Œä¸€è·¯é«˜æ­ŒçŒ›è¿›ï¼›ç¬”ä¸‹æœ‰é”‹èŠ’ï¼Œå¿ƒä¸­æœ‰
æ–¹å‘ï¼Œåœ¨æ¯ä¸€æ¬¡è€ƒè¯•ä¸é€‰æ‹©ä¸­éƒ½èƒ½ä»å®¹åº”å¯¹ã€ç¨³æ­¥è¿›é˜¶ã€‚
æ„¿è¿™ä¸€å¹´ï¼šæœ‰å†²åŠ²ï¼Œè€Œä¸å¤±åˆ†å¯¸ï¼›æœ‰é‡å¿ƒï¼Œä¹Ÿæœ‰åº•æ°”ï¼›æœ‰
å¥”è·‘çš„å‹‡æ°”ï¼Œæ›´æœ‰æŠµè¾¾çš„å®åŠ›ã€‚

é©¬åˆ°æˆåŠŸï¼Œä¸‡äº‹èƒœæ„ã€‚
æ–°æ˜¥å¤§å‰ï¼
`;

        const AutoCoding = () => {
            const containerRef = useRef(null);
            const [code, setCode] = useState("");
            
            useEffect(() => {
    let currentIndex = 0;
    const fullText = SOURCE_CODE_TEXT;

    const interval = setInterval(() => {
        const charCount = Math.floor(Math.random() * 3) + 1;
        const nextIndex = Math.min(currentIndex + charCount, fullText.length);

        setCode(fullText.substring(0, nextIndex));
        currentIndex = nextIndex;

        // âœ… å¦‚æœå·²ç»æ‰“å®Œ â†’ åœæ­¢å®šæ—¶å™¨
        if (currentIndex >= fullText.length) {
            clearInterval(interval);   // å…³é”®ä¿®æ”¹
        }

        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        if (containerRef.current) {
            containerRef.current.scrollTop = containerRef.current.scrollHeight;
        }

    }, 30);

    return () => clearInterval(interval);
}, []);

            // Syntax highlighting using Prism
            const highlightedCode = useMemo(() => {
    if (window.Prism) {
        let html = Prism.highlight(code, Prism.languages.javascript, 'javascript');

        html = html.replace(
            /é©¬å¹´æ–°æ˜¥ï¼Œä¸‡è±¡å¥”è…¾ã€‚/g,
            '<span style="color: #FF0000; font-weight: bold; text-shadow: 0 0 5px rgba(255,0,0,0.5);">é©¬å¹´æ–°æ˜¥ï¼Œä¸‡è±¡å¥”è…¾ã€‚</span>'
        );

        html = html.replace(
            /æ„¿ä½ åœ¨æ–°çš„ä¸€å¹´é‡Œï¼Œå¦‚éªé©¬æ‰¬è¹„ï¼Œæ­¥å±¥åšå®šã€ç›®å…‰æ¸…æœ—â€”â€”/g,
            '<span style="color: #FFFFFF; font-weight: bold;">æ„¿ä½ åœ¨æ–°çš„ä¸€å¹´é‡Œï¼Œå¦‚éªé©¬æ‰¬è¹„ï¼Œæ­¥å±¥åšå®šã€ç›®å…‰æ¸…æœ—â€”â€”</span>'
        );

        html = html.replace(
            /æ„¿å­¦ä¸šå¦‚éªé©¬è¸æ˜¥ï¼Œä¸€è·¯é«˜æ­ŒçŒ›è¿›ï¼›ç¬”ä¸‹æœ‰é”‹èŠ’ï¼Œå¿ƒä¸­æœ‰/g,
            '<span style="color: #FFFFFF; font-weight: bold;">æ„¿å­¦ä¸šå¦‚éªé©¬è¸æ˜¥ï¼Œä¸€è·¯é«˜æ­ŒçŒ›è¿›ï¼›ç¬”ä¸‹æœ‰é”‹èŠ’ï¼Œå¿ƒä¸­æœ‰</span>'
        );
		
		html = html.replace(
            /æ–¹å‘ï¼Œåœ¨æ¯ä¸€æ¬¡è€ƒè¯•ä¸é€‰æ‹©ä¸­éƒ½èƒ½ä»å®¹åº”å¯¹ã€ç¨³æ­¥è¿›é˜¶ã€‚/g,
            '<span style="color: #FFFFFF; font-weight: bold;">æ–¹å‘ï¼Œåœ¨æ¯ä¸€æ¬¡è€ƒè¯•ä¸é€‰æ‹©ä¸­éƒ½èƒ½ä»å®¹åº”å¯¹ã€ç¨³æ­¥è¿›é˜¶ã€‚</span>'
        );
		
		html = html.replace(
            /æ„¿è¿™ä¸€å¹´ï¼šæœ‰å†²åŠ²ï¼Œè€Œä¸å¤±åˆ†å¯¸ï¼›æœ‰é‡å¿ƒï¼Œä¹Ÿæœ‰åº•æ°”ï¼›æœ‰/g,
            '<span style="color: #FF0000; font-weight: bold;">æ„¿è¿™ä¸€å¹´ï¼šæœ‰å†²åŠ²ï¼Œè€Œä¸å¤±åˆ†å¯¸ï¼›æœ‰é‡å¿ƒï¼Œä¹Ÿæœ‰åº•æ°”ï¼›æœ‰</span>'
        );
		
		html = html.replace(
            /å¥”è·‘çš„å‹‡æ°”ï¼Œæ›´æœ‰æŠµè¾¾çš„å®åŠ›ã€‚/g,
            '<span style="color: #FF0000; font-weight: bold;">å¥”è·‘çš„å‹‡æ°”ï¼Œæ›´æœ‰æŠµè¾¾çš„å®åŠ›ã€‚</span>'
        );
		
		html = html.replace(
            /é©¬åˆ°æˆåŠŸï¼Œä¸‡äº‹èƒœæ„ã€‚/g,
            '<span style="color: #FF0000; font-weight: bold;">é©¬åˆ°æˆåŠŸï¼Œä¸‡äº‹èƒœæ„ã€‚</span>'
        );
		
		html = html.replace(
            /æ–°æ˜¥å¤§å‰ï¼/g,
            '<span style="color: #FF0000; font-weight: bold;">æ–°æ˜¥å¤§å‰ï¼</span>'
        );

        return html;
    }
    return code;
}, [code]);

            return (
                <div className="absolute inset-0 z-50 bg-black/5 overflow-hidden pointer-events-none">
                    <div 
                        ref={containerRef}
                        className="code-container w-full h-full pt-6 pr-6 pb-6 pl-64 overflow-y-auto"
                        style={{ fontFamily: "'Fira Code', 'Consolas', monospace" }}
                    >
                        <pre className="text-sm md:text-base leading-relaxed text-gray-300 whitespace-pre-wrap break-all">
                            <code 
                                className="language-javascript cursor"
                                dangerouslySetInnerHTML={{ __html: highlightedCode }}
                            />
                        </pre>
                    </div>
                    {/* Gradient overlay to fade out top */}
                    <div className="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-black to-transparent pointer-events-none"></div>
                </div>
            );
        };

        const MusicPlayer = () => {
            const [playing, setPlaying] = useState(false);
            const audioRef = useRef(null);

            const togglePlay = () => {
                if (audioRef.current) {
                    if (playing) {
                        audioRef.current.pause();
                    } else {
                        audioRef.current.play().catch(e => console.log("Playback prevented:", e));
                    }
                    setPlaying(!playing);
                }
            };

            return (
                <div className="absolute top-4 right-4 z-50">
                    <audio ref={audioRef} loop>
                        <source src="music.mp3" type="audio/mp3" />
                    </audio>
                    
                </div>
            );
        };
        const ParticleTitle = () => {
            const [positions, colors] = useMemo(() => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 1024;
                canvas.height = 512; // Increased height for two lines
                // Use a bold font, smaller size
                ctx.font = 'bold 100px "Microsoft YaHei", sans-serif'; // Reduced from 140px to 100px
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw two lines, closer together
                ctx.fillText('2026', canvas.width / 2, canvas.height * 0.35);
                ctx.fillText('æ–°å¹´å¿«ä¹', canvas.width / 2, canvas.height * 0.65);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const p = [];
                const c = [];
                
                // Pure Bright Red
                const red = new THREE.Color('#FF0000'); 
                
                // Sample density (Decreased step for higher density)
                const step = 2; 
                
                for (let y = 0; y < canvas.height; y += step) {
                    for (let x = 0; x < canvas.width; x += step) {
                        const index = (y * canvas.width + x) * 4;
                        if (data[index + 3] > 128) { // if alpha > 128
                            // Map canvas coordinates to 3D space
                            // Scale down to fit screen 
                            const px = (x - canvas.width / 2) * 0.02;
                            const py = -(y - canvas.height / 2) * 0.02;
                            p.push(px, py + 1.5, 0); // Moved down from 2.5 to 1.5
                            
                            // Pure Red (No sparkles)
                            c.push(red.r, red.g, red.b);
                        }
                    }
                }
                return [new Float32Array(p), new Float32Array(c)];
            }, []);

            return (
                <Points positions={positions} colors={colors} stride={3}>
                    <PointMaterial 
                        transparent 
                        vertexColors 
                        size={0.07}  // Increased size
                        sizeAttenuation={true} 
                        depthWrite={false} 
                        blending={THREE.AdditiveBlending}
                        opacity={1.0}
                    />
                </Points>
            );
        };

        const FloatingLanterns = () => {
            const count = 50;
            const points = useRef(null);
            
            const [positions, phases] = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const ph = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    pos[i * 3] = (Math.random() - 0.5) * 20; // x
                    pos[i * 3 + 1] = (Math.random() - 0.5) * 10 - 2; // y
                    pos[i * 3 + 2] = (Math.random() - 0.5) * 10 - 5; // z
                    ph[i] = Math.random() * Math.PI * 2;
                }
                return [pos, ph];
            }, []);

            useFrame((state) => {
                if (!points.current) return;
                const time = state.clock.getElapsedTime();
                const posAttr = points.current.geometry.attributes.position;
                
                for (let i = 0; i < count; i++) {
                    let y = posAttr.array[i * 3 + 1];
                    // Gentle float up
                    y += 0.005;
                    // Reset if too high
                    if (y > 6) y = -6;
                    
                    // Gentle sway
                    const x = posAttr.array[i * 3] + Math.sin(time + phases[i]) * 0.002;
                    
                    posAttr.array[i * 3] = x;
                    posAttr.array[i * 3 + 1] = y;
                }
                posAttr.needsUpdate = true;
            });

            return (
                <Points ref={points} positions={positions} stride={3} frustumCulled={false}>
                    <PointMaterial 
                        transparent 
                        color="#FF0000" 
                        size={0.15} // Small but visible lanterns
                        sizeAttenuation={true} 
                        depthWrite={false} 
                        opacity={0.8}
                    />
                </Points>
            );
        };

        const ClassicFireworks = () => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                let width, height;
                let fireworks = [];
                let particles = [];
                let animationFrameId;

                const resize = () => {
                    width = canvas.width = window.innerWidth;
                    height = canvas.height = window.innerHeight;
                };
                window.addEventListener('resize', resize);
                resize();

                class Firework {
                    constructor() {
                        this.x = Math.random() * width;
                        this.y = height;
                        this.targetY = Math.random() * (height * 0.4) + height * 0.1;
                        this.speed = Math.random() * 3 + 6;
                        this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.1;
                        this.vx = Math.cos(this.angle) * this.speed;
                        this.vy = Math.sin(this.angle) * this.speed;
                        this.hue = Math.random() * 360;
                        this.dead = false;
                        this.trail = [];
                    }

                    update() {
                        this.trail.push({x: this.x, y: this.y});
                        if(this.trail.length > 5) this.trail.shift();

                        this.x += this.vx;
                        this.y += this.vy;
                        this.vy += 0.05;

                        if (this.vy >= 0 || this.y <= this.targetY) {
                            this.explode();
                            this.dead = true;
                        }
                    }

                    draw() {
                        ctx.strokeStyle = `hsl(${this.hue}, 100%, 50%)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        if(this.trail.length > 0) {
                            ctx.moveTo(this.trail[0].x, this.trail[0].y);
                            for(let p of this.trail) ctx.lineTo(p.x, p.y);
                        } else {
                            ctx.moveTo(this.x, this.y);
                        }
                        ctx.lineTo(this.x, this.y);
                        ctx.stroke();
                    }

                    explode() {
                        const count = 100;
                        for (let i = 0; i < count; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue));
                        }
                    }
                }

                class Particle {
                    constructor(x, y, hue) {
                        this.x = x;
                        this.y = y;
                        this.hue = hue;
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 5 + 1;
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        this.friction = 0.95;
                        this.gravity = 0.1;
                        this.alpha = 1;
                        this.decay = Math.random() * 0.015 + 0.005;
                    }

                    update() {
                        this.vx *= this.friction;
                        this.vy *= this.friction;
                        this.vy += this.gravity;
                        this.x += this.vx;
                        this.y += this.vy;
                        this.alpha -= this.decay;
                    }

                    draw() {
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.alpha})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                function animate() {
                    // Transparent fade effect to work with existing background
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
                    ctx.fillRect(0, 0, width, height);
                    ctx.globalCompositeOperation = 'source-over';

                    if (Math.random() < 0.05) {
                        fireworks.push(new Firework());
                    }

                    for (let i = fireworks.length - 1; i >= 0; i--) {
                        fireworks[i].update();
                        fireworks[i].draw();
                        if (fireworks[i].dead) {
                            fireworks.splice(i, 1);
                        }
                    }

                    for (let i = particles.length - 1; i >= 0; i--) {
                        particles[i].update();
                        particles[i].draw();
                        if (particles[i].alpha <= 0) {
                            particles.splice(i, 1);
                        }
                    }

                    animationFrameId = requestAnimationFrame(animate);
                }

                animate();

                return () => {
                    window.removeEventListener('resize', resize);
                    cancelAnimationFrame(animationFrameId);
                };
            }, []);

            return (
                <canvas 
                    ref={canvasRef} 
                    className="absolute inset-0 z-[5] pointer-events-none" 
                />
            );
        };

        const NewYearParticles = () => {
            const [shapeIndex, setShapeIndex] = useState(0);

            useEffect(() => {
                const interval = setInterval(() => {
                    setShapeIndex((prev) => (prev + 1) % SCENE_SHAPES.length);
                }, SHAPE_SWITCH_INTERVAL);
                return () => clearInterval(interval);
            }, []);

            return (
                <div className="w-full h-full bg-black relative">
                    
                    {/* Background Music Player */}
                    <MusicPlayer />
                    
                    {/* Auto Typing Background */}
                    <AutoCoding />

                    {/* 2D Classic Fireworks Layer */}
                    <ClassicFireworks />

                    {/* 3D Scene with transparent background */}
                    <Canvas 
                        gl={{ alpha: true }}
                        camera={{ position: [0, 0, 10], fov: 50 }} 
                        dpr={[1, 2]} 
                        style={{ width: '100vw', height: '100vh', position: 'relative', zIndex: 10 }}
                    >
                        {/* No background color to let Code show through */}
                        
                        <Resizer />

                        <ParticleTitle />

                        <MorphingScene shapeIndex={shapeIndex} />

                        <FallingSnow />
                        
                        <FloatingLanterns />

                        {/* Background Stars */}
                        <Points positions={new Float32Array(4000 * 3).map(() => (Math.random() - 0.5) * 50)}>
                            <PointMaterial transparent color="#ffffff" size={0.04} opacity={0.4} sizeAttenuation={true} />
                        </Points>

                    </Canvas>
                    
                    <div
                        className="absolute inset-0 z-40 cursor-pointer"
                        onClick={() => setShapeIndex((prev) => (prev + 1) % SCENE_SHAPES.length)}
                    />
                </div>
            );
        };

        const App = () => {
            return (
                <div style={{ width: '100vw', height: '100vh' }}>
                    <NewYearParticles />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
</script>

</body>
</html>
